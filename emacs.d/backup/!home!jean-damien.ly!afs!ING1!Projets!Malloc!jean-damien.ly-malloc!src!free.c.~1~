#include "malloc.h"
#include <stddef.h>
#include <unistd.h>

int mystrlen(char *a)
{
    int i = 0;
    while (a[i] != '\0')
        i++;
    return i;
}

void put(char *a)
{
    write(STDOUT_FILENO, a, mystrlen(a));
    write(STDOUT_FILENO, "\n", 1);
}

void print_int(char *a, int size, char *b)
{
    if (a)
        write(STDOUT_FILENO, a, mystrlen(a) - 1);
    char abc[8];
    int i = 0;
    while (size != 0)
    {
        abc[i] = size % 10 + '0';
        size = size / 10 ;
        i++;
    }
    abc[i] = '\0';
    for (int j = 0; j != i / 2; j++)
    {
        char save = abc[j];
        abc[j] = abc[i - 1 - j];
        abc[i - 1 - j] = save;
    }
    write(STDOUT_FILENO, abc, i);
    if (b)
        write(STDOUT_FILENO, b, mystrlen(b) - 1);
}

static char set_struct_page(char a)
{
    if (a == 'a')
        return 'b';
    return 'a';
}

static struct chunk* get_base(void)
{
    static struct chunk *base = NULL;
    if (base == NULL)
    {
        void *addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (addr == MAP_FAILED)
            return NULL;
        base = addr;
        base->size = 4096 - sizeof(struct chunk);
        base->free = 'f';
        char *chartmp = addr;
        chartmp += sizeof(struct chunk);
        void *tmp = chartmp;
        base->data = tmp;
        base->page = 'a';
    }
    return base;
}

static struct chunk* find_chunk(size_t size)
{
    struct chunk *b = get_base();
    while ((b) && ((b->free != 'f') ||
                               (b->size < size + sizeof(struct chunk))))
    {
        b = b->next;
    }
    if (b == NULL)
    {
        b = get_base();
        while (b->next)
            b = b->next;
        void *addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (addr == MAP_FAILED)
            return NULL;
        struct chunk *new = addr;
        new->size = 4096 - sizeof(struct chunk);
        new->free = 'f';
        char *chartmp = addr;
        chartmp += sizeof(struct chunk);
        void *tmp = chartmp;
        new->data = tmp;
        b->next = new;
        new->prev = b;
        new->page = 'a';
        if (b->page == 'a')
            new->page = 'b';
        return find_chunk(size);
    }
    return b;
}

struct chunk *get_chunk(void *p)
{
    struct chunk *base = get_base();
    struct chunk *c = p;
    if ((!c) || (!base))
        return NULL;
    if (&base > &c)
        return NULL;
    char *ctmp = p;
    ctmp -= sizeof(struct chunk);
    void *tmp = ctmp;
    struct chunk *chunk = tmp;
    return chunk;
}


void *alloc(size_t size)
{
    struct chunk *chunk = find_chunk(size);
    if (!chunk)
        return NULL;
    chunk->free = '\0';
    if (chunk->size <= size + sizeof(struct chunk))
        return chunk->data;
    void *ptr = chunk->data;
    char *chartmp = chunk->data;
    chartmp += size;
    void *tmp = chartmp;
    struct chunk *new = tmp;
    struct chunk *save = chunk->next;
    chunk->next = new;
    if (save)
        save->prev = new;
    new->prev = chunk;
    new->next = save;
    new->page = set_struct_page(chunk->page);
    new->size = chunk->size - size - sizeof(struct chunk);
    new->free = 'f';
    chartmp += sizeof(struct chunk);
    void *ntmp = chartmp;
    new->data = ntmp;
    chunk->size = size;
    return ptr;
}


static int check_address(struct chunk *cur, struct chunk *next)
{
    void *vcur = cur;
    char *ccur = vcur;
    ccur += cur->size + sizeof(struct chunk);
    vcur = ccur;
    cur = vcur;
    return (cur == next);
}

static void *free_big(struct chunk *chunk, void *ptr)
{
    struct chunk *prev = chunk->prev;
    struct chunk *next = chunk->next;
    if (prev)
        prev->next = next;
    if (next)
        next->prev = prev;
    munmap(ptr, chunk->size + sizeof(struct chunk));
    return NULL;
}

void *free_ptr(void *ptr)
{
    struct chunk *c = get_chunk(ptr);
    if (!c)
        return NULL;
    c->free = 'f';
    if (c->size > 4096 - sizeof(struct chunk))
        return free_big(c, ptr);
    char p = c->page;
    if ((c->next) && (c->next->free == 'f') && (c->next->page == p))
    {
        if (check_address(c, c->next))
        {
            c->next->prev = c->prev;
            c->size += c->next->size + sizeof(struct chunk);
            if (c->next->next)
                c->next->next->prev = c;
            c->next = c->next->next;
        }
    }
    if ((c->prev) && (c->prev->free == 'f') && (c->prev->page == p))
    {
        if (check_address(c->prev, c))
        {
            c->prev->next = c->next;
            c->prev->size += c->size + sizeof(struct chunk);
            if (c->next)
                c->next->prev = c->prev;
        }
    }
    return NULL;
}

void *big_alloc(size_t size)
{
    struct chunk *base = get_base();
    while (base->next)
        base = base->next;
    void *addr = mmap(NULL, allign(size) + sizeof(struct chunk), PROT_READ
                      | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED)
        return NULL;
    struct chunk *new = addr;
    new->size = size - sizeof(struct chunk);
    new->free = '\0';
    char *chartmp = addr;
    chartmp += sizeof(struct chunk);
    void *tmp = chartmp;
    new->data = tmp;
    new->prev = base;
    new->page = set_struct_page(base->page);
    base->next = new;
    return tmp;
}

void *reallocation(void *ptr, size_t size)
{
    struct chunk *chunk = get_chunk(ptr);
    if (!chunk)
        return NULL;
    size_t available = 0;
    char p = chunk->page;
    while ((chunk->next) && (chunk->page == p) && (chunk->next->free == 'f'))
    {
        available += chunk->size;
        chunk = chunk->next;
    }
    if (available < size)
        return NULL;
    chunk = get_chunk(ptr);
    while (available > 0)
    {
        available -= chunk->size;
        chunk->free = '\0';
        chunk = chunk->next;
        if (!chunk)
            break;
    }
    return ptr;
}